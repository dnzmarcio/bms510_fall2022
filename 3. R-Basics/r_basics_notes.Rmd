---
title: "R- Basics"
author: "Marcio A Diniz"
date: "January 19, 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Objects in R

R is a calculator:

```{r}
# Add
5 + 5

# Subtract
10 - 5

# Multiply.
3*5

# Divide.
10/2
```

R objects are like small boxes, where we can store only one piece of information. Boxes have names and the action of storing a calculation in a box is performed using the operator `<-`:

```{r}
x <- 5 + 5
y <- 10 - 5
w <- 3*5
z <- 10/2

#Look the environment tab, now there are four objects.
```

Visualizing the values of objects, i.e., opening and looking into the boxes requires only to type the boxes' names:

```{r}
x
y
w
z
```

Vectors are like stacked boxes. We can create vectors combining scalars:
```{r}
x <- c(10, 15, 20)
x
y <- seq(10, 20, by = 5)
y
w <- 1:10
w
z <- rep(1, 10)
z

# We can still do calculations using vectors;
w + z
```

Each vector has a class. The main classes are numeric, character and logical. Numeric vectors contain numbers; character vectors contain strings, and logical vectors contain logical statements.

```{r}
# x is a numeric vector;
x <- c(1, 2, 3)
is.numeric(x)
class(x)

# y is a character vector;
y <- c("pizza", "lasagna", "risotto")
is.character(y)
class(y)

# z is a logical vector;
z <- c(TRUE, FALSE, T, F)
is.logical(z)
class(z)
```

Numeric vectors can also be classified into integer and double vector.

```{r}
# x is integer vector because each number is followed by L;
x <- c(1L, 2L, 3L) 
is.numeric(x)
is.integer(x)

# y is not a integer vector!
y <- c(1, 2, 3)
is.integer(y)

# z is a double vector;
z <- c(1.5, 3.9, 10.1)
is.numeric(z)
is.double(z)

# y is a double vector!
is.double(y)
```

Character and numeric vectors that assume few pre-specified values can be transformed into factors. Factors have the attribute *levels*.

```{r}
# Character to factor
sex <- rep(c("F", "M"), 4)
class(sex)
sex <- factor(sex, levels = c("F", "M"))
class(sex)

# Numeric to factor
sex <- rep(c(0, 1), 4)
class(sex)
sex <- factor(sex, levels = c(0, 1), labels = c("M", "F"))
class(sex)

# Acessing the attributes levels of a factor
nlevels(sex)
levels(sex)
```

How can we access or modify the content of a given element of the vector?

## Subsetting vectors

We subset vectors using brackets.

```{r}
y <- c("pizza", "lasagna", "risotto")
y

# What is the size of the vector?
length(y)

# Acessing the content of each position
y[1]
y[2]
y[3]
y[c(1, 2)]
y[c(2, 1)]
y[1:2]

# Modifying the content of each position
y[2] <- "pasta"
y
```


## Combining vectors of the same class

Vectors of the same class can be combined into matrices. 

```{r}
x <- c(1, 2, 3)
y <- c(4, 5, 6)
z <- c(7, 8, 9)

# As columns
m <- cbind(x, y, z)
class(m)
m

# As rows
m <- rbind(x, y, z)
class(m)
m

x <- c("a", "b", "c")
y <- c("d", "e", "f")
z <- c("g", "h", "i")

# As columns
m <- cbind(x, y, z)
class(m)
m

# As rows
m <- rbind(x, y, z)
class(m)
m
```

We also can subset matrices. However, two position indexes are required because matrices are rectangular data structures.

```{r}
m[1, ]
m[, 1]
m[1, 1]
```

What happens if we try to combine vectors of different classes?

```{r}
x <- c(1, 2, 3)
y <- c("d", "e", "f")
z <- c(T, F, T)

m <- cbind(x, y, z)
class(m)
m
```

If we create matrices that combine vectors of different classes, R will coerce vectors of different classes to the highest level class, i.e., the most accomodating of other classes. The hierarchy among classes is character, numeric, logical.

How can be combine vectors of different classes without losing their initial class?

```{r}
x <- c(1, 2, 3)
y <- c("d", "e", "f")
z <- c("g", "h", "i")

m <- data.frame(x, y, z)
class(m)
m
```

Datasets are a combination in the columns of objects with different classes, therefore datasets are data frames in R.

## Data frames and variations

```{r}
library(readr)
sepsis_wide <- read_csv("data/sepsis_wide.csv")
sepsis_wide
str(sepsis_wide)
```

Data frames have the attribute names.

```{r}
names(sepsis_wide)
```


How do we access each vector of a data frame? We use *$*. Then, we can use brackets to subset as we have done for vectors.

```{r}
sepsis_wide$treat
```

The vectors *treat*, *race* and *death* are currently numeric vectors, but actually they are factors. Let's transform them into factors!

```{r}
sepsis_wide$treat <- factor(sepsis_wide$treat, levels = 0:1,
                            labels = c("Control",
                                       "Ibuprofenol"))

sepsis_wide$race <- factor(sepsis_wide$race, levels = 0:2,
                            labels = c("White",
                                       "African American",
                                       "Hispanic"))

sepsis_wide$death <- factor(sepsis_wide$death, levels = 0:1,
                           labels = c("Alive", "Dead"))

```

How do we access each value in a data frame? We use brackets similarly when subsetting vectors.

```{r}
# What is the dimmension of a data.frame?
dim(sepsis_wide)

# Subsetting rows
sepsis_wide[1, ]
sepsis_wide[4, ]

# Subsetting columns
sepsis_wide[, 1]
sepsis_wide[4, ]

# Subsetting values
sepsis_wide[4, 1]
sepsis_wide[1, 4]
```

## Logical statements and vectors

Logical statements often will be used when we are manipulating datasets. They can be classified into simple and composite statements. The main simple logical statements are below. 

```{r}
# Less than
1 < 2
# Greater than
1 > 2
# Less than or equal to
1 <= 2
# Greater than or equal to
1 >= 2
# Equal to
1 == 2
# Different from
1 != 2

```

The last two can also be used with character of factor vectors.

```{r}
x <- "pizza"
y <- "lasagna"

x == y
x != y
```

Any logical statement can be stored and accessed later.
```{r}
condition <- x == y
condition
```


Based on simple logical statements, we can define composite ones:

```{r}
# & indicates that both simple statements should happen to the composite statement be true;
1 < 2 & 4 > 3
1 < 2 & 4 == 3

# | indicates that at least one of the statements should happen to the composite statement be true;
1 < 2 | 4 == 3
```

Logical statements also can be defined for vectors. R will evaluate the logical statement for each position of the vector:
```{r}
x <- 1:3
y <- 4:6
z <- seq(1, 6, by = 2)

x < y
x > z
x == 1
z != 3
```

We can transform logical statements into position indexes using the function `which`.

```{r}
x <- 1:3
y <- 4:6
condition <- x < y
which(condition)
```

## Logical statements and data frames

How can we subset the dataset `sepsis` for african american patients?

```{r}
sepsis_wide$race
condition <- sepsis_wide$race == "African American"
which(condition)

sepsis_wide[condition, ]
```

